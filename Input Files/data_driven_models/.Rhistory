chains <- 3
bl_start <- Sys.time()
model  <- jags.model(m_blasso, data = data, n.chains=chains, quiet=TRUE)
update(model, burn)
samps  <- coda.samples(model, variable.names=c("beta"),
thin=5, n.iter=iters)
print(Sys.time() - bl_start)
plot(samps)
effectiveSize(samps)
beta    <- c()
for(l in 1:chains){
beta <- rbind(beta, samps[[l]])
}
# colnames(beta) <- names
effectiveSize(samps)
Inc_Prob <- apply(beta!=0, 2, mean)
Q        <- t(apply(beta, 2, quantile,c(0.5,0.05,0.95)))
out      <- cbind(Inc_Prob, Q)
View(out)
library(MASS)
data(birthwt)
q <- 0.7
#### SSVS Implementation ####
library(rjags)
# Y is the birthweight, X is the predictors
Y <- birthwt[,10]
X <- birthwt[,1:9]
X <- scale(X)
# define the model in jags
m <- textConnection("model{
for(i in 1:n){
Y[i]   ~ dnorm(pi[i], taue)
pi[i] <- alpha + X[i,1]*beta[1] + X[i,2]*beta[2] + X[i,3]*beta[3] +
X[i,4]*beta[4] + X[i,5]*beta[5] + X[i,6]*beta[6] +
X[i,7]*beta[7] + X[i,8]*beta[8] + X[i,9]*beta[9]
}
for(j in 1:9){
beta[j] <- gamma[j]*delta[j]
gamma[j] ~ dbern(q)
delta[j] ~ dnorm(0,taub*taue)
}
alpha  ~ dnorm(0,0.01)
taue   ~ dgamma(0.1,0.1)
taub   ~ dgamma(0.1,0.1)
}")
# set variables and run MCMC
n      <- length(Y)
data   <- list(Y=Y,X=X,n=n,q=q)
burn   <- 5000
iters  <- 10000
chains <- 3
ssvs_start <- Sys.time()
model  <- jags.model(m, data = data, n.chains=chains, quiet=TRUE)
update(model, burn)
samps  <- coda.samples(model, variable.names=c("beta"),
thin=5, n.iter=iters)
print(Sys.time() - ssvs_start)
plot(samps)
# calculate the inclusion probability
beta    <- c()
for(l in 1:chains){
beta <- rbind(beta,samps[[l]])
}
# colnames(beta) <- names
effectiveSize(samps)
Inc_Prob <- apply(beta!=0, 2, mean)
Q        <- t(apply(beta, 2, quantile,c(0.5,0.05,0.95)))
out      <- cbind(Inc_Prob, Q)
library(MASS)
data(birthwt)
q <- 0.7
#### SSVS Implementation ####
library(rjags)
# Y is the birthweight, X is the predictors
Y <- birthwt[,10]
X <- birthwt[,1:9]
X <- scale(X)
# define the model in jags
m <- textConnection("model{
for(i in 1:n){
Y[i]   ~ dnorm(pi[i], taue)
pi[i] <- alpha + X[i,1]*beta[1] + X[i,2]*beta[2] + X[i,3]*beta[3] +
X[i,4]*beta[4] + X[i,5]*beta[5] + X[i,6]*beta[6] +
X[i,7]*beta[7] + X[i,8]*beta[8] + X[i,9]*beta[9]
}
for(j in 1:9){
beta[j] <- gamma[j]*delta[j]
gamma[j] ~ dbern(q)
delta[j] ~ dnorm(0,taub*taue)
}
alpha  ~ dnorm(0,0.01)
taue   ~ dgamma(0.1,0.1)
taub   ~ dgamma(0.1,0.1)
}")
# set variables and run MCMC
n      <- length(Y)
data   <- list(Y=Y,X=X,n=n,q=q)
burn   <- 5000
iters  <- 10000
chains <- 3
ssvs_start <- Sys.time()
model  <- jags.model(m, data = data, n.chains=chains, quiet=TRUE)
update(model, burn)
samps  <- coda.samples(model, variable.names=c("beta"),
thin=5, n.iter=iters)
print(Sys.time() - ssvs_start)
plot(samps)
# calculate the inclusion probability
beta_ssvs    <- c()
for(l in 1:chains){
beta_ssvs <- rbind(beta_ssvs,samps[[l]])
}
# colnames(beta) <- names
effectiveSize(samps)
Inc_Prob <- apply(beta_ssvs!=0, 2, mean)
Q        <- t(apply(beta_ssvs, 2, quantile,c(0.5,0.05,0.95)))
out      <- cbind(Inc_Prob, Q)
#### BLASSO Implmentation ####
m_blasso <- textConnection("model{
for(i in 1:n){
Y[i]   ~ dnorm(inprod(X[i,], beta[]), taue)
}
for(j in 1:9){
beta[j] ~ ddexp(0, taue*taub)
}
taue   ~ dgamma(0.1,0.1)
taub   ~ dgamma(0.1,0.1)
}")
# set variables and run MCMC
n      <- length(Y)
data   <- list(Y=Y,X=X,n=n)
burn   <- 5000
iters  <- 10000
chains <- 3
bl_start <- Sys.time()
model  <- jags.model(m_blasso, data = data, n.chains=chains, quiet=TRUE)
update(model, burn)
samps  <- coda.samples(model, variable.names=c("beta"),
thin=5, n.iter=iters)
print(Sys.time() - bl_start)
plot(samps)
effectiveSize(samps)
beta_bl    <- c()
for(l in 1:chains){
beta_bl <- rbind(beta_bl, samps[[l]])
}
# colnames(beta) <- names
effectiveSize(samps)
Inc_Prob <- apply(beta_bl!=0, 2, mean)
Q        <- t(apply(beta_bl, 2, quantile,c(0.5,0.05,0.95)))
out      <- cbind(Inc_Prob, Q)
sum                      <- summary(samps)
sum$statistics           <- round(sum$statistics,3)
sum$quantiles            <- round(sum$quantiles,3)
sum
View(beta_bl)
View(beta_ssvs)
mean(beta_bl[1])
beta_bl!=0
beta_svss!=0
beta_ssvs!=0
View(beta_ssvs)
View(beta_bl)
library(MASS)
data(birthwt)
q <- 0.7
#### SSVS Implementation ####
library(rjags)
# Y is the birthweight, X is the predictors
Y <- birthwt[,10]
X <- birthwt[,1:9]
X <- scale(X)
# define the model in jags
m <- textConnection("model{
for(i in 1:n){
Y[i]   ~ dnorm(pi[i], taue)
pi[i] <- alpha + X[i,1]*beta[1] + X[i,2]*beta[2] + X[i,3]*beta[3] +
X[i,4]*beta[4] + X[i,5]*beta[5] + X[i,6]*beta[6] +
X[i,7]*beta[7] + X[i,8]*beta[8] + X[i,9]*beta[9]
}
for(j in 1:9){
beta[j] <- gamma[j]*delta[j]
gamma[j] ~ dbern(q)
delta[j] ~ dnorm(0,taub*taue)
}
alpha  ~ dnorm(0,0.01)
taue   ~ dgamma(0.1,0.1)
taub   ~ dgamma(0.1,0.1)
}")
# set variables and run MCMC
n      <- length(Y)
data   <- list(Y=Y,X=X,n=n,q=q)
burn   <- 5000
iters  <- 10000
chains <- 3
ssvs_start <- Sys.time()
model  <- jags.model(m, data = data, n.chains=chains, quiet=TRUE)
update(model, burn)
samps  <- coda.samples(model, variable.names=c("beta"),
thin=5, n.iter=iters)
print(Sys.time() - ssvs_start)
plot(samps)
# calculate the inclusion probability
beta_ssvs    <- c()
for(l in 1:chains){
beta_ssvs <- rbind(beta_ssvs,samps[[l]])
}
# colnames(beta) <- names
effectiveSize(samps)
Inc_Prob <- apply(beta_ssvs!=0, 2, mean)
Q        <- t(apply(beta_ssvs, 2, quantile,c(0.5,0.05,0.95)))
out      <- cbind(Inc_Prob, Q)
#### BLASSO Implmentation ####
m_blasso <- textConnection("model{
for(i in 1:n){
Y[i]   ~ dnorm(alpha + inprod(X[i,], beta[]), taue)
}
for(j in 1:9){
beta[j] ~ ddexp(0, taue*taub)
}
alpha  ~ dnorm(0,0.01)
taue   ~ dgamma(0.1,0.1)
taub   ~ dgamma(0.1,0.1)
}")
# set variables and run MCMC
n      <- length(Y)
data   <- list(Y=Y,X=X,n=n)
burn   <- 5000
iters  <- 10000
chains <- 3
bl_start <- Sys.time()
model  <- jags.model(m_blasso, data = data, n.chains=chains, quiet=TRUE)
update(model, burn)
samps  <- coda.samples(model, variable.names=c("beta"),
thin=5, n.iter=iters)
print(Sys.time() - bl_start)
plot(samps)
effectiveSize(samps)
beta_bl    <- c()
for(l in 1:chains){
beta_bl <- rbind(beta_bl, samps[[l]])
}
# colnames(beta) <- names
effectiveSize(samps)
Inc_Prob <- apply(beta_bl!=0, 2, mean)
Q        <- t(apply(beta_bl, 2, quantile,c(0.5,0.05,0.95)))
out      <- cbind(Inc_Prob, Q)
sum                      <- summary(samps)
sum$statistics           <- round(sum$statistics,3)
sum$quantiles            <- round(sum$quantiles,3)
sum
#### Reverse jump MCMC implementation ####
library(nimble)
lmIndicatorCode <- nimbleCode({
taue ~ dgamma(0.1,0.1)
taub ~ dgamma(0.1,0.1)
alpha ~ dnorm(0,0.01)
for(i in 1:numVars) {
z[i] ~ dbern(q) ## indicator variable for each coefficient
beta[i] ~ dnorm(0, taub)
zbeta[i] <- z[i] * beta[i]  ## indicator * beta
}
for(i in 1:N) {
pred.y[i] <- inprod(alpha + X[i, 1:numVars], zbeta[1:numVars])
y[i] ~ dnorm(pred.y[i], taue)
}
})
## Set up the model.
lmIndicatorConstants <- list(N = length(Y), numVars = 9, q = q)
lmIndicatorInits <- list(sigma = 1, psi = 0.5,
beta = rnorm(lmIndicatorConstants$numVars),
z = sample(0:1, lmIndicatorConstants$numVars, 0.5))
lmIndicatorData  <- list(y = Y, X = X)
lmIndicatorModel <- nimbleModel(code = lmIndicatorCode, constants = lmIndicatorConstants,
inits = lmIndicatorInits, data = lmIndicatorData)
lmIndicatorConf <- configureMCMC(lmIndicatorModel)
lmIndicatorConf$addMonitors('z')
## Check the assigned samplers
rj_start <- Sys.time()
mcmcIndicatorRJ <- buildMCMC(lmIndicatorConf)
cIndicatorModel <- compileNimble(lmIndicatorModel)
CMCMCIndicatorRJ <- compileNimble(mcmcIndicatorRJ, project = lmIndicatorModel)
set.seed(1)
system.time(samplesIndicator <- runMCMC(CMCMCIndicatorRJ, niter = 10000,
nburnin = 5000,
nchains = 3))
print(Sys.time() - rj_start)
par(mfrow = c(1, 1))
zCols <- grep("z\\[", colnames(samplesIndicator))
posterior_inclusion_prob <- colMeans(samplesIndicator[, zCols])
plot(1:9, posterior_inclusion_prob,
xlab = "beta", ylab = "inclusion probability",
main = "Inclusion probabilities for each beta")
# colnames(beta) <- names
effectiveSize(samps)
Inc_Prob <- apply(beta_ssvs!=0, 2, mean)
Q        <- t(apply(beta_ssvs, 2, quantile,c(0.5,0.05,0.95)))
out      <- cbind(Inc_Prob, Q)
posterior_inclusion_prob <- colMeans(samplesIndicator[, zCols])
View(samplesIndicator)
View(samplesIndicator)
library(dplyr)
Reduce(full_join, samplesIndicator)
samplesIndicator <- merge(samplesIndicator$chain1, samplesIndicator$chain2,
samplesIndicator$chain3)
View(samplesIndicator)
samplesIndicator$chain1
samplesIndicator <- merge(samplesIndicator$chain1, samplesIndicator$chain2,
samplesIndicator$chain3, by=c("z[1]", "z[2]", "z[3]",
"z[4]", "z[5]", "z[6]",
"z[7]", "z[8]", "z[9]"))
samplesIndicator <- rbind(samplesIndicator$chain1, samplesIndicator$chain2,
samplesIndicator$chain3)
posterior_inclusion_prob <- colMeans(samplesIndicator[, zCols])
plot(1:9, posterior_inclusion_prob,
xlab = "beta", ylab = "inclusion probability",
main = "Inclusion probabilities for each beta")
View(samplesIndicator)
zCols <- grep("z\\[", colnames(samplesIndicator))
posterior_inclusion_prob <- colMeans(samplesIndicator[, zCols])
plot(1:9, posterior_inclusion_prob,
xlab = "beta", ylab = "inclusion probability",
main = "Inclusion probabilities for each beta")
posterior_inclusion_prob
sum                      <- summary(samps)
sum$statistics           <- round(sum$statistics,3)
sum$quantiles            <- round(sum$quantiles,3)
sum
knitr::opts_chunk$set(echo = TRUE)
library(MASS)
data(birthwt)
# global variable for inclusion probability
q <- 0.7
#### SSVS Implementation ####
library(rjags)
# Y is the birthweight, X is the predictors
Y <- birthwt[,10]
X <- birthwt[,1:9]
X <- scale(X)
# define the model in jags
m <- textConnection("model{
for(i in 1:n){
Y[i]   ~ dnorm(pi[i], taue)
pi[i] <- alpha + X[i,1]*beta[1] + X[i,2]*beta[2] + X[i,3]*beta[3] +
X[i,4]*beta[4] + X[i,5]*beta[5] + X[i,6]*beta[6] +
X[i,7]*beta[7] + X[i,8]*beta[8] + X[i,9]*beta[9]
}
for(j in 1:9){
beta[j] <- gamma[j]*delta[j]
gamma[j] ~ dbern(q)
delta[j] ~ dnorm(0,taub*taue)
}
alpha  ~ dnorm(0,0.01)
taue   ~ dgamma(0.1,0.1)
taub   ~ dgamma(0.1,0.1)
}")
# set variables and run MCMC
n      <- length(Y)
data   <- list(Y=Y,X=X,n=n,q=q)
burn   <- 5000
iters  <- 10000
chains <- 3
ssvs_start <- Sys.time()
model  <- jags.model(m, data = data, n.chains=chains, quiet=TRUE)
update(model, burn)
samps  <- coda.samples(model, variable.names=c("beta"),
thin=5, n.iter=iters)
print(Sys.time() - ssvs_start)
plot(samps)
#### SSVS Implementation ####
library(rjags)
# Y is the birthweight, X is the predictors
Y <- birthwt[,10]
X <- birthwt[,1:9]
X <- scale(X)
# define the model in jags
m <- textConnection("model{
for(i in 1:n){
Y[i]   ~ dnorm(pi[i], taue)
pi[i] <- alpha + X[i,1]*beta[1] + X[i,2]*beta[2] + X[i,3]*beta[3] +
X[i,4]*beta[4] + X[i,5]*beta[5] + X[i,6]*beta[6] +
X[i,7]*beta[7] + X[i,8]*beta[8] + X[i,9]*beta[9]
}
for(j in 1:9){
beta[j] <- gamma[j]*delta[j]
gamma[j] ~ dbern(q)
delta[j] ~ dnorm(0,taub*taue)
}
alpha  ~ dnorm(0,0.01)
taue   ~ dgamma(0.1,0.1)
taub   ~ dgamma(0.1,0.1)
}")
# set variables and run MCMC
n      <- length(Y)
data   <- list(Y=Y,X=X,n=n,q=q)
burn   <- 5000
iters  <- 10000
chains <- 3
ssvs_start <- Sys.time()
model  <- jags.model(m, data = data, n.chains=chains, quiet=TRUE)
update(model, burn)
samps  <- coda.samples(model, variable.names=c("beta"),
thin=5, n.iter=iters)
print(Sys.time() - ssvs_start)
par(mfrow = c(3, 2))
plot(samps)
library(MASS)
data(birthwt)
q <- 0.7
#### SSVS Implementation ####
library(rjags)
# Y is the birthweight, X is the predictors
Y <- birthwt[,10]
X <- birthwt[,1:9]
X <- scale(X)
# define the model in jags
m <- textConnection("model{
for(i in 1:n){
Y[i]   ~ dnorm(pi[i], taue)
pi[i] <- alpha + X[i,1]*beta[1] + X[i,2]*beta[2] + X[i,3]*beta[3] +
X[i,4]*beta[4] + X[i,5]*beta[5] + X[i,6]*beta[6] +
X[i,7]*beta[7] + X[i,8]*beta[8] + X[i,9]*beta[9]
}
for(j in 1:9){
beta[j] <- gamma[j]*delta[j]
gamma[j] ~ dbern(q)
delta[j] ~ dnorm(0,taub*taue)
}
alpha  ~ dnorm(0,0.01)
taue   ~ dgamma(0.1,0.1)
taub   ~ dgamma(0.1,0.1)
}")
# set variables and run MCMC
n      <- length(Y)
data   <- list(Y=Y,X=X,n=n,q=q)
burn   <- 5000
iters  <- 10000
chains <- 3
ssvs_start <- Sys.time()
model  <- jags.model(m, data = data, n.chains=chains, quiet=TRUE)
update(model, burn)
samps  <- coda.samples(model, variable.names=c("beta"),
thin=5, n.iter=iters)
print(Sys.time() - ssvs_start)
plot(samps)
# calculate the inclusion probability
beta_ssvs    <- c()
for(l in 1:chains){
beta_ssvs <- rbind(beta_ssvs,samps[[l]])
}
# colnames(beta) <- names
effectiveSize(samps)
Inc_Prob <- apply(beta_ssvs!=0, 2, mean)
Q        <- t(apply(beta_ssvs, 2, quantile,c(0.5,0.05,0.95)))
out      <- cbind(Inc_Prob, Q)
#### BLASSO Implmentation ####
m_blasso <- textConnection("model{
for(i in 1:n){
Y[i]   ~ dnorm(alpha + inprod(X[i,], beta[]), taue)
}
for(j in 1:9){
beta[j] ~ ddexp(0, taue*taub)
}
alpha  ~ dnorm(0,0.01)
taue   ~ dgamma(0.1,0.1)
taub   ~ dgamma(0.1,0.1)
}")
# set variables and run MCMC
n      <- length(Y)
data   <- list(Y=Y,X=X,n=n)
burn   <- 5000
iters  <- 10000
chains <- 3
bl_start <- Sys.time()
model  <- jags.model(m_blasso, data = data, n.chains=chains, quiet=TRUE)
update(model, burn)
samps  <- coda.samples(model, variable.names=c("beta"),
thin=5, n.iter=iters)
print(Sys.time() - bl_start)
plot(samps)
effectiveSize(samps)
beta_bl    <- c()
for(l in 1:chains){
beta_bl <- rbind(beta_bl, samps[[l]])
}
# colnames(beta) <- names
effectiveSize(samps)
Inc_Prob <- apply(beta_bl!=0, 2, mean)
Q        <- t(apply(beta_bl, 2, quantile,c(0.5,0.05,0.95)))
out      <- cbind(Inc_Prob, Q)
sum                      <- summary(samps)
sum$statistics           <- round(sum$statistics,3)
sum$quantiles            <- round(sum$quantiles,3)
sum
setwd(r"C:\Users\squar\Documents\hydraulic_ABM\Input Files\pmt_models")
setwd("C:\\Users\\squar\\Documents\\hydraulic_ABM\\Input Files\\pmt_models")
list.files()
substr('slekdsg.bif', 1, nchar('slekdsg.bif')-3)
library(bnlearn)
setwd("C:\\Users\\squar\\Documents\\hydraulic_ABM\\Input Files\\pmt_models")
for (i in list.files()){
fitted <- read.bif(i)
out_file <- paste0(substr(i, 1, nchar(i)-3), 'net')
write.net(out_file, fitted)
}
library(bnlearn)
setwd("C:\\Users\\squar\\Documents\\hydraulic_ABM\\Input Files\\data_driven_models")
for (i in list.files()){
fitted <- read.bif(i)
out_file <- paste0(substr(i, 1, nchar(i)-3), 'net')
write.net(out_file, fitted)
}
